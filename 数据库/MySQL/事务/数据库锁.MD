# 数据库锁

应用软件锁另见：[Java锁](../../../软件开发/原理探析/Java锁.MD)。
对于一次的数据修改，我们可以大概将其分为三步：

* 获取数据
* 修改数据
* 提交修改

这里假设有A、B两个角色修改数据。

## 乐观锁

对数据改动持乐观态度：认为在查询到修改的过程中，大概不会有其他人来修改数据。

### 实现方式

* 引入版本

给数据表添加一个version字段，每次修改提交后，版本号递增。

如A在获取数据时，数据版本是v2，那提交时执行的语句就是：

```sql
update a_table
set a_column = '*',
    where version = v2
```

如果在中途，B修改了数据，那数据库对应数据就会变成v3，A对v2的修改就失效了，不会产生异常。

## 悲观锁

对数据改动持悲观态度，认为在查询修改提交期间，极有可能会有人来修改数据。

A在获取数据后，就对数据加锁，提交修改后释放。途中由于加锁，B读取时会阻塞B，读不了数据，所以数据不会被修改。

使用悲观锁可以保证不会发生异常情况，如丢失修改、重复修改等问题。

### 实现方式

#### 排它锁（Exclusive Lock）

是一种互斥锁，也叫写锁。当一个线程获得排他锁时，其他线程就不能同时访问该资源了，直到该线程释放该锁。主要适用于需要进行修改的资源，如文件、数据库记录等。

`select … for update`

从字面意思就可以知道，该语句不单单是查询，而是为了后续的修改，是要对数据加锁的。
按照 select 中 where 的字段，又可分为行锁和表锁。

* 若 where 查询索引字段，该条数据行锁（根据经验，满足同条件索引的数据也会锁定，之前听过行锁锁的是索引，不是数据）；
* 查询普通字段，会导致表锁（未验证）；
* 给普通字段加索引后，锁从表级降为行级（未验证）；
* 修改数据，让大部分数据满足索引条件，锁会从行级升为表级；
  因为索引列中目标值太多，占大部时，会走全索引扫描（未验证，这就牵扯到，目标值占多少会走全索引？），会将该字段视为普通字段，故致表锁。

[引用出处](https://blog.csdn.net/qq_32565537/article/details/126439743)，
其中引用[这个视频](https://www.bilibili.com/video/BV1YU4y1C7j4/?share_source=copy_web&vd_source=bf91fef3a99fcdb25f54a2281be92cf0)，
有时间看一下。

#### 共享锁（Shared Lock）

也叫读锁，与排他锁不同的是，多个线程可以同时获得共享锁，因为共享锁是为了允许多个线程同时读取同一份资源而设计的。

### 优缺点
