## 脏读 （Dirty Read）

### 定义

读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。
读到了并不一定最终存在的数据，这就是脏读。

### 解释

脏读最大的问题就是会读到可能不存在的数据。

比如，事务B的更新数据被事务A读取，但是事务B回滚了，更新数据全部还原，也就是说事务A刚刚读到的数据并没有存在于数据库中。

从宏观来看，就是事务A读出了一条不存在的数据，这个问题是很严重的。

## 不可重复读 （Non-Repeatable Read）

### 定义

在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。

### 解释

这是由于查询时系统中其他事务修改的提交而引起的。

比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。

更易懂的说法：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据并修改数据。
那么，在第一个事务的两次读数据之间。
由于另一个事务的修改，那么第一个事务两次读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即
原始读取不可重复。

## 幻读 （Phantom Read）

注意不要理解为[不可重复读](#不可重复读-non-repeatable-read)

### 定义

幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。

具体来说：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。

### 解释

这里是在[RR](./事务的特性和隔离级别.MD#可重复读repeatable-read)级别下研究,因为 RU / RC 下还会存在脏读、不可重复读，故我们就以
RR 级别来研究 幻读，排除其他干扰。

事务A，查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。

事务B，新增一条 id=5 的记录，并提交事务。

1. 事务A启动,查询 id=5,发现没有记录
2. 事务B启动,新增并提交
3. 事务A,再次查询id=5,发现还是没有记录（rr级别下多次查询使用的是首次查询时的readview，不是最新数据，所以没有读到数据）
4. 事务A,插入一条 id=5 的数据。
5. 事务A 提交事务，发现报错。

这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读。

不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。

参照：[详读脏读、不可重复读、幻读](https://blog.csdn.net/weixin_41814871/article/details/124996364)

幻读的根本原因是，rr级别中的select使用快照读，而update却用了当前读，如果**快照读和当前读都出现在同一个事务中，就可能幻读。**
快照读解决了不可重复读的问题，实现可重复读，同时也带来了幻读。
