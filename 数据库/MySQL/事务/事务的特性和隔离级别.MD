# 什么是事务

## 概念

事务（Transaction）是一种机制，也是一个操作序列，是访问和更新数据库的程序执行单元，包含了一组数据库操作命令。

事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，
因此**事务是一个不可分割的工作逻辑单元**。

在数据库系统上执行并发操作时，事务是作为最小的控制单元来使用的，特别适用于多用户同时操作的数据库系统。

MySQL 支持多事务并发（两个或多个事件在同一时间间隔发生）执行

## 特性 ACID
事务必须具备以下四个属性，简称ACID属性

### 原子性(Atomicity)

事务是一个完整的操作，其中的语句要么全执行，要么都不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log

### 持久性

保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log

### 隔离性

对数据进行修改的所有并发事务是彼此隔离的，事务必须是独立的，它不应以任何方式依赖或影响其他事务。

InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、
MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）

### 一致性

当事务完成时，数据必须处于一致状态。 这是事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障

参照：[什么是事务，事务的特性](https://blog.csdn.net/m0_71188683/article/details/127957059)

# 隔离级别

MySQL支持四种事务隔离级别：

## 读未提交（Read Uncommitted）

最低的隔离级别，事务可以读取尚未提交的数据。

这个级别会导致[“脏读”](./并发读的三类问题.MD#脏读-dirty-read)的问题。
在这个级别下，事务对数据的读取没有任何限制，也不会对其他事务的读取和写入造成阻塞。

## 读已提交（Read Committed）

Oracle默认隔离级别是RC。

在这个隔离级别下，事务只能读取已经提交的数据，可以避免脏读问题。

但是，在同一个事务中，多次读取同一个数据可能得到不同结果（其他事务修改该数据时），
导致[“不可重复读”](./并发读的三类问题.MD#不可重复读-non-repeatable-read)的问题。

在本级别下，同一事务中，每一次select都会创建一个readview。

## 可重复读（Repeatable Read）

MySQL 的默认事务隔离级别是RR。实际上RC已经足够日常使用，很多公司会手动将MySQL设置成RC。

在这个隔离级别下，事务在读取数据时会对数据进行锁定，确保其他事务无法修改这些数据。

这样可以避免“不可重复读”的问题，但是会导致[“幻读”](./并发读的三类问题.MD#幻读-phantom-read)的问题。

在本级别下，同一事务中，第一次select会创建readview，后续select都不会再创建，这叫做快照读，这实质上读的是历史数据。
然而如果在事务中使用了update语句，就会触发当前读，这时读的就是最新数据。往后的select会从这个当前读开始，重新创建readview，然后快照读。

## 序列化（Serializable）

最高的隔离级别，事务之间的读写操作串行执行，可以避免所有并发问题。

但是这种级别的性能开销非常大，不适用于高并发的场景。

参照：[MySQL默认事务隔离级别](https://baijiahao.baidu.com/s?id=1764959949515557916&wfr=spider&for=pc)
